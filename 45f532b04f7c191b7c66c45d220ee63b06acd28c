---
type: decisions
spec: arch-lifecycle-automation
timestamp: '2025-12-15T06:50:19.368617Z'
summary: Use PROGRESS.md as Single Source of Truth
phase: architecture
tags:
- arch-lifecycle-automation
- adr
- architecture
- ci-cd
---

## Context
Implementation state needs to be tracked across multiple documents (README.md, IMPLEMENTATION_PLAN.md, REQUIREMENTS.md, CHANGELOG.md). We need to decide where the authoritative state lives.

Options considered:
1. Distributed state: Each document owns its own state
2. Central state: One file is authoritative, others are derived
3. External state: JSON/database file separate from markdown

## Decision
Use a new `PROGRESS.md` file as the single source of truth for all implementation state. Other documents are synchronized from PROGRESS.md.

## Alternatives Considered
- Distributed state
- JSON/database file

---
type: decisions
spec: arch-lifecycle-automation
timestamp: '2025-12-15T06:50:31.583348Z'
summary: Hybrid Checkpoint System for Context Loading
phase: architecture
tags:
- arch-lifecycle-automation
- adr
- architecture
- ci-cd
---

## Context
When `/arch:i` starts, it needs to provide Claude with implementation context. We need to decide how much to load and how.

Options considered:
1. Full document load (all planning docs into context)
2. Condensed brief (summary only)
3. Progressive loading (current phase detail + overview)
4. Reference mode (lazy loading on demand)
5. Hybrid checkpoint (brief + persistent PROGRESS.md)

## Decision
Use Hybrid Checkpoint System: Load a condensed implementation brief at startup, maintain state in PROGRESS.md that persists across sessions.

## Alternatives Considered
- Full document load
- Condensed brief only
- Progressive loading
- Reference mode

---
type: decisions
spec: arch-lifecycle-automation
timestamp: '2025-12-15T06:50:31.635340Z'
summary: Auto-Detect Project from Branch Name
phase: architecture
tags:
- arch-lifecycle-automation
- adr
- architecture
- git
- ci-cd
---

## Context
When user runs `/arch:i`, we need to determine which architecture project to work on. Options:

1. Always require explicit project ID argument
2. Auto-detect from current git branch
3. Interactive selection from active projects
4. Combination with fallback chain

## Decision
Auto-detect project from current git branch name, with explicit argument as override and interactive selection as fallback for ambiguous cases.

Detection logic:
1. If explicit argument provided, use it
2. Parse current branch name (e.g., `fix/arch-commands` → `arch-commands`)
3. Search `docs/architecture/active/*/README.md` for matching slug
4. If multiple matches, prompt user to select
5. If no matches, provide helpful error

## Alternatives Considered
- Always require argument
- Interactive selection only

---
type: decisions
spec: arch-lifecycle-automation
timestamp: '2025-12-15T06:50:31.726221Z'
summary: Hierarchical Status Rollup
phase: architecture
tags:
- arch-lifecycle-automation
- adr
- architecture
---

## Context
We need to determine project and phase status from granular task states. How should rollup work?

Options:
1. Per-task only (no aggregation)
2. Per-phase only
3. Per-deliverable
4. Hierarchical (task → phase → project)

## Decision
Use hierarchical rollup: Task completion rolls up to phase progress, phase completion rolls up to project status.

Rollup rules:
- Phase progress = (done + skipped) / total tasks
- Phase status: pending → in-progress (first task starts) → done (all tasks done/skipped)
- Project status: draft → in-progress (first task starts) → completed (all phases done)

## Alternatives Considered
- Per-task only
- Per-phase only
- Per-deliverable

---
type: decisions
spec: arch-lifecycle-automation
timestamp: '2025-12-15T06:50:31.772352Z'
summary: Divergence Tracking with User Notification
phase: architecture
tags:
- arch-lifecycle-automation
- adr
- architecture
- ci-cd
---

## Context
Implementation often diverges from plans: tasks get added, skipped, or modified. How should we handle this?

Options:
1. Silently update the plan
2. Block divergence (force adherence to plan)
3. Track and flag for user review
4. Track and auto-approve
5. Track, flag, and allow user to approve/reject

## Decision
Track divergences in PROGRESS.md Divergence Log, notify user, and allow them to approve or flag for review. Divergences don't block progress but are explicitly recorded.

Divergence types: `added`, `skipped`, `modified`, `reordered`
Resolution states: `approved`, `flagged`, `pending-review`

## Alternatives Considered
- Silent updates
- Block divergence
- Track and auto-approve

---
type: decisions
spec: arch-lifecycle-automation
timestamp: '2025-12-15T06:50:31.816002Z'
summary: Use Opus 4.5 Model for `/arch:i`
phase: architecture
tags:
- arch-lifecycle-automation
- adr
- architecture
---

## Context
The existing `/arch` commands use a model tiering strategy:
- `/arch:p` (planning): Opus 4.5 (complex reasoning)
- `/arch:s` (status): Sonnet (simpler operations)
- `/arch:c` (close): Sonnet (simpler operations)

What model should `/arch:i` use?

## Decision
Use Opus 4.5 for `/arch:i` because it requires:
- Intelligent detection of task completion from implementation work
- Context synthesis across multiple planning documents
- Nuanced divergence detection and user communication
- Complex state management and rollup calculations

## Alternatives Considered
- Sonnet
- Hybrid (Sonnet + escalate to Opus)

---
type: decisions
spec: claude-spec-plugin
timestamp: '2025-12-15T06:50:31.864870Z'
summary: Custom Prompt Capture vs Claude Code Native Logs
phase: architecture
tags:
- claude-spec-plugin
- adr
- architecture
---

## Context
Claude Code may maintain internal session transcripts. The question was whether we could leverage those instead of maintaining a custom prompt capture system.

## Decision
Maintain **custom prompt capture system** within the plugin.

---
type: decisions
spec: claude-spec-plugin
timestamp: '2025-12-15T06:50:31.918913Z'
summary: Command Prefix Rename (/arch:* → /cs:*)
phase: architecture
tags:
- claude-spec-plugin
- adr
- architecture
---

## Context
The plugin needs a command prefix. Options were `/arch:*`, `/spec:*`, `/cs:*`, or `/cspec:*`.

## Decision
Use **`/cs:*`** prefix (short for claude-spec).

---
type: decisions
spec: claude-spec-plugin
timestamp: '2025-12-15T06:50:31.966126Z'
summary: No Legacy Aliases
phase: architecture
tags:
- claude-spec-plugin
- adr
- architecture
---

## Context
During migration, we could provide `/arch:*` aliases that redirect to `/cs:*` commands.

## Decision
**No aliases** - clean break from old commands.

---
type: decisions
spec: claude-spec-plugin
timestamp: '2025-12-15T06:50:32.011407Z'
summary: Project Directory Rename
phase: architecture
tags:
- claude-spec-plugin
- adr
- architecture
---

## Context
Projects were stored in `docs/architecture/active/`. With the rename, options were:
- Keep old location (backward compatible)
- Rename to `docs/spec/active/` (consistent branding)
- Use hidden `.claude-spec/` directory

## Decision
Rename to **`docs/spec/active/`** with one-time migration via `/cs:migrate`.

---
type: decisions
spec: claude-spec-plugin
timestamp: '2025-12-15T06:50:32.056489Z'
summary: Worktree Commands Structure
phase: architecture
tags:
- claude-spec-plugin
- adr
- architecture
- ci-cd
---

## Context
Worktree manager functionality could be exposed as:
- Skill triggers only ("spin up worktrees")
- Explicit commands (`/cs:wt:*`)
- Both

## Decision
**Both** - skill triggers AND explicit commands.

Commands:
- `/cs:wt:create` - Create worktrees with agents
- `/cs:wt:status` - View worktree status
- `/cs:wt:cleanup` - Clean up worktrees

---
type: decisions
spec: claude-spec-plugin
timestamp: '2025-12-15T06:50:32.119325Z'
summary: Hidden Prompt Log File
phase: architecture
tags:
- claude-spec-plugin
- adr
- architecture
---

## Context
Prompt log file naming options:
- `PROMPT_LOG.json` (visible, all caps)
- `prompts.json` (visible, lowercase)
- `.prompt-log.json` (hidden)

## Decision
Use **`.prompt-log.json`** (hidden file).

---
type: decisions
spec: claude-spec-plugin
timestamp: '2025-12-15T06:50:32.168027Z'
summary: Dynamic Agent Catalog Integration
phase: architecture
tags:
- claude-spec-plugin
- adr
- architecture
- ci-cd
---

## Context
Plugin needs to reference specialist agents. Options:
- Bundle agent definitions in plugin
- Assume host has agents, document as prerequisite
- Dynamically read from host's `~/.claude/agents/`

## Decision
**Dynamically read from host's `~/.claude/agents/`** and CLAUDE.md.

---
type: decisions
spec: prompt-capture-log
timestamp: '2025-12-15T06:50:32.211179Z'
summary: Use NDJSON for Log Format
phase: architecture
tags:
- prompt-capture-log
- adr
- architecture
---

## Context
The log file needs to store multiple entries over time, potentially across many sessions. We need a format that supports:
- Atomic appends without reading/rewriting the entire file
- Resistance to corruption (one bad entry shouldn't invalidate all data)
- Easy parsing for analysis
- Human readability for debugging

## Decision
Use NDJSON (Newline-Delimited JSON) format where each line is a self-contained JSON object.

## Alternatives Considered
- JSON Array
- SQLite
- Plain text

---
type: decisions
spec: prompt-capture-log
timestamp: '2025-12-15T06:50:32.257829Z'
summary: Python for Hook Implementation
phase: architecture
tags:
- prompt-capture-log
- adr
- architecture
- python
- hooks
---

## Context
The hook needs to integrate with Claude Code's hook system, which supports command execution. The existing hookify plugin is written in Python.

## Decision
Implement the prompt capture hook in Python to match the existing hookify plugin infrastructure.

## Alternatives Considered
- Node.js/TypeScript
- Bash script
- Go binary

---
type: decisions
spec: prompt-capture-log
timestamp: '2025-12-15T06:50:32.303395Z'
summary: File-Based Toggle Marker
phase: architecture
tags:
- prompt-capture-log
- adr
- architecture
- ci-cd
---

## Context
Need a way to persist the "logging enabled" state across Claude Code sessions. The toggle must be:
- Project-specific (different projects can have different states)
- Visible and debuggable
- Persistent without a database

## Decision
Use a marker file (`.prompt-log-enabled`) in the project directory. Presence = enabled, absence = disabled.

## Alternatives Considered
- JSON config file
- Environment variable
- Global settings.json
- Database

---
type: decisions
spec: prompt-capture-log
timestamp: '2025-12-15T06:50:32.352788Z'
summary: Filter Pipeline Order (Secrets → Profanity)
phase: architecture
tags:
- prompt-capture-log
- adr
- architecture
---

## Context
Both profanity and secrets need to be filtered. The order of filtering could affect results.

## Decision
Filter secrets first, then profanity.

## Alternatives Considered
- Profanity → Secrets
- Single pass

---
type: decisions
spec: prompt-capture-log
timestamp: '2025-12-15T06:50:32.400094Z'
summary: Response Summaries via Heuristics
phase: architecture
tags:
- prompt-capture-log
- adr
- architecture
---

## Context
Need to capture Claude's responses for complete interaction logging, but full responses are too verbose (often 1000+ words). Options for summarization:
- Use LLM to summarize (adds latency, cost)
- Use heuristics (fast, free, less accurate)

## Decision
Use heuristic-based summarization: extract first paragraph, key bullet points, truncate to 500 characters.

## Alternatives Considered
- LLM summarization
- Full response logging
- No response capture

---
type: decisions
spec: prompt-capture-log
timestamp: '2025-12-15T06:50:32.449375Z'
summary: Hook Integration Point
phase: architecture
tags:
- prompt-capture-log
- adr
- architecture
- hooks
---

## Context
Need to choose how to integrate with Claude Code's hook system. Options:
- Standalone hook in `~/.claude/hooks/`
- Extension to hookify plugin
- New dedicated plugin

## Decision
Implement as a standalone hook in `~/.claude/hooks/` with its own registration, separate from but compatible with hookify.

## Alternatives Considered
- Extend hookify
- New plugin

---
type: decisions
spec: quality-release-ci-github-act
timestamp: '2025-12-15T06:50:32.497152Z'
summary: Use uv for Python Package Management
phase: architecture
tags:
- quality-release-ci-github-act
- adr
- architecture
- python
- ci-cd
---

## Context
The CI pipeline needs to install Python dependencies quickly and reliably. Options include pip, poetry, pipenv, and uv.

## Decision
Use **uv** (by Astral) for package management in CI and local development.

## Alternatives Considered
- pip + pip-tools
- poetry
- pipenv

---
type: decisions
spec: quality-release-ci-github-act
timestamp: '2025-12-15T06:50:32.561770Z'
summary: Use ruff for Linting and Formatting
phase: architecture
tags:
- quality-release-ci-github-act
- adr
- architecture
- python
---

## Context
Python code needs formatting and linting. Traditional tools include Black, isort, flake8, pylint.

## Decision
Use **ruff** for both formatting and linting.

## Alternatives Considered
- Black + isort + flake8
- Black + pylint
- autopep8

---
type: decisions
spec: quality-release-ci-github-act
timestamp: '2025-12-15T06:50:32.608549Z'
summary: Use Stable Action Versions (v4 over v6)
phase: architecture
tags:
- quality-release-ci-github-act
- adr
- architecture
- git
- python
- ci-cd
- testing
---

## Context
GitHub Actions like `actions/checkout` have multiple major versions available. v6 is latest but requires runner v2.327.1+.

## Decision
Use **v4** versions of core actions for stability.

```yaml
actions/checkout@v4
actions/setup-python@v4  # Note: We use astral-sh/setup-uv instead
actions/upload-artifact@v4
actions/download-artifact@v4
```

Use `astral-sh/setup-uv@v4` for Python setup (includes uv and Python).

## Alternatives Considered
- v6 (latest)
- Pin to SHA
- Use latest tag
