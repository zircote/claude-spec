---
type: decisions
spec: arch-lifecycle-automation
timestamp: '2025-12-15T06:50:19.368617Z'
summary: Use PROGRESS.md as Single Source of Truth
phase: architecture
tags:
- arch-lifecycle-automation
- adr
- architecture
- ci-cd
---

## Context
Implementation state needs to be tracked across multiple documents (README.md, IMPLEMENTATION_PLAN.md, REQUIREMENTS.md, CHANGELOG.md). We need to decide where the authoritative state lives.

Options considered:
1. Distributed state: Each document owns its own state
2. Central state: One file is authoritative, others are derived
3. External state: JSON/database file separate from markdown

## Decision
Use a new `PROGRESS.md` file as the single source of truth for all implementation state. Other documents are synchronized from PROGRESS.md.

## Alternatives Considered
- Distributed state
- JSON/database file

---
type: decisions
spec: arch-lifecycle-automation
timestamp: '2025-12-15T06:50:31.583348Z'
summary: Hybrid Checkpoint System for Context Loading
phase: architecture
tags:
- arch-lifecycle-automation
- adr
- architecture
- ci-cd
---

## Context
When `/arch:i` starts, it needs to provide Claude with implementation context. We need to decide how much to load and how.

Options considered:
1. Full document load (all planning docs into context)
2. Condensed brief (summary only)
3. Progressive loading (current phase detail + overview)
4. Reference mode (lazy loading on demand)
5. Hybrid checkpoint (brief + persistent PROGRESS.md)

## Decision
Use Hybrid Checkpoint System: Load a condensed implementation brief at startup, maintain state in PROGRESS.md that persists across sessions.

## Alternatives Considered
- Full document load
- Condensed brief only
- Progressive loading
- Reference mode

---
type: decisions
spec: arch-lifecycle-automation
timestamp: '2025-12-15T06:50:31.635340Z'
summary: Auto-Detect Project from Branch Name
phase: architecture
tags:
- arch-lifecycle-automation
- adr
- architecture
- git
- ci-cd
---

## Context
When user runs `/arch:i`, we need to determine which architecture project to work on. Options:

1. Always require explicit project ID argument
2. Auto-detect from current git branch
3. Interactive selection from active projects
4. Combination with fallback chain

## Decision
Auto-detect project from current git branch name, with explicit argument as override and interactive selection as fallback for ambiguous cases.

Detection logic:
1. If explicit argument provided, use it
2. Parse current branch name (e.g., `fix/arch-commands` → `arch-commands`)
3. Search `docs/architecture/active/*/README.md` for matching slug
4. If multiple matches, prompt user to select
5. If no matches, provide helpful error

## Alternatives Considered
- Always require argument
- Interactive selection only

---
type: decisions
spec: arch-lifecycle-automation
timestamp: '2025-12-15T06:50:31.726221Z'
summary: Hierarchical Status Rollup
phase: architecture
tags:
- arch-lifecycle-automation
- adr
- architecture
---

## Context
We need to determine project and phase status from granular task states. How should rollup work?

Options:
1. Per-task only (no aggregation)
2. Per-phase only
3. Per-deliverable
4. Hierarchical (task → phase → project)

## Decision
Use hierarchical rollup: Task completion rolls up to phase progress, phase completion rolls up to project status.

Rollup rules:
- Phase progress = (done + skipped) / total tasks
- Phase status: pending → in-progress (first task starts) → done (all tasks done/skipped)
- Project status: draft → in-progress (first task starts) → completed (all phases done)

## Alternatives Considered
- Per-task only
- Per-phase only
- Per-deliverable

---
type: decisions
spec: arch-lifecycle-automation
timestamp: '2025-12-15T06:50:31.772352Z'
summary: Divergence Tracking with User Notification
phase: architecture
tags:
- arch-lifecycle-automation
- adr
- architecture
- ci-cd
---

## Context
Implementation often diverges from plans: tasks get added, skipped, or modified. How should we handle this?

Options:
1. Silently update the plan
2. Block divergence (force adherence to plan)
3. Track and flag for user review
4. Track and auto-approve
5. Track, flag, and allow user to approve/reject

## Decision
Track divergences in PROGRESS.md Divergence Log, notify user, and allow them to approve or flag for review. Divergences don't block progress but are explicitly recorded.

Divergence types: `added`, `skipped`, `modified`, `reordered`
Resolution states: `approved`, `flagged`, `pending-review`

## Alternatives Considered
- Silent updates
- Block divergence
- Track and auto-approve

---
type: decisions
spec: arch-lifecycle-automation
timestamp: '2025-12-15T06:50:31.816002Z'
summary: Use Opus 4.5 Model for `/arch:i`
phase: architecture
tags:
- arch-lifecycle-automation
- adr
- architecture
---

## Context
The existing `/arch` commands use a model tiering strategy:
- `/arch:p` (planning): Opus 4.5 (complex reasoning)
- `/arch:s` (status): Sonnet (simpler operations)
- `/arch:c` (close): Sonnet (simpler operations)

What model should `/arch:i` use?

## Decision
Use Opus 4.5 for `/arch:i` because it requires:
- Intelligent detection of task completion from implementation work
- Context synthesis across multiple planning documents
- Nuanced divergence detection and user communication
- Complex state management and rollup calculations

## Alternatives Considered
- Sonnet
- Hybrid (Sonnet + escalate to Opus)

---
type: decisions
spec: claude-spec-plugin
timestamp: '2025-12-15T06:50:31.864870Z'
summary: Custom Prompt Capture vs Claude Code Native Logs
phase: architecture
tags:
- claude-spec-plugin
- adr
- architecture
---

## Context
Claude Code may maintain internal session transcripts. The question was whether we could leverage those instead of maintaining a custom prompt capture system.

## Decision
Maintain **custom prompt capture system** within the plugin.

---
type: decisions
spec: claude-spec-plugin
timestamp: '2025-12-15T06:50:31.918913Z'
summary: Command Prefix Rename (/arch:* → /cs:*)
phase: architecture
tags:
- claude-spec-plugin
- adr
- architecture
---

## Context
The plugin needs a command prefix. Options were `/arch:*`, `/spec:*`, `/cs:*`, or `/cspec:*`.

## Decision
Use **`/cs:*`** prefix (short for claude-spec).

---
type: decisions
spec: claude-spec-plugin
timestamp: '2025-12-15T06:50:31.966126Z'
summary: No Legacy Aliases
phase: architecture
tags:
- claude-spec-plugin
- adr
- architecture
---

## Context
During migration, we could provide `/arch:*` aliases that redirect to `/cs:*` commands.

## Decision
**No aliases** - clean break from old commands.

---
type: decisions
spec: claude-spec-plugin
timestamp: '2025-12-15T06:50:32.011407Z'
summary: Project Directory Rename
phase: architecture
tags:
- claude-spec-plugin
- adr
- architecture
---

## Context
Projects were stored in `docs/architecture/active/`. With the rename, options were:
- Keep old location (backward compatible)
- Rename to `docs/spec/active/` (consistent branding)
- Use hidden `.claude-spec/` directory

## Decision
Rename to **`docs/spec/active/`** with one-time migration via `/cs:migrate`.

---
type: decisions
spec: claude-spec-plugin
timestamp: '2025-12-15T06:50:32.056489Z'
summary: Worktree Commands Structure
phase: architecture
tags:
- claude-spec-plugin
- adr
- architecture
- ci-cd
---

## Context
Worktree manager functionality could be exposed as:
- Skill triggers only ("spin up worktrees")
- Explicit commands (`/cs:wt:*`)
- Both

## Decision
**Both** - skill triggers AND explicit commands.

Commands:
- `/cs:wt:create` - Create worktrees with agents
- `/cs:wt:status` - View worktree status
- `/cs:wt:cleanup` - Clean up worktrees

---
type: decisions
spec: claude-spec-plugin
timestamp: '2025-12-15T06:50:32.119325Z'
summary: Hidden Prompt Log File
phase: architecture
tags:
- claude-spec-plugin
- adr
- architecture
---

## Context
Prompt log file naming options:
- `PROMPT_LOG.json` (visible, all caps)
- `prompts.json` (visible, lowercase)
- `.prompt-log.json` (hidden)

## Decision
Use **`.prompt-log.json`** (hidden file).

---
type: decisions
spec: claude-spec-plugin
timestamp: '2025-12-15T06:50:32.168027Z'
summary: Dynamic Agent Catalog Integration
phase: architecture
tags:
- claude-spec-plugin
- adr
- architecture
- ci-cd
---

## Context
Plugin needs to reference specialist agents. Options:
- Bundle agent definitions in plugin
- Assume host has agents, document as prerequisite
- Dynamically read from host's `~/.claude/agents/`

## Decision
**Dynamically read from host's `~/.claude/agents/`** and CLAUDE.md.

---
type: decisions
spec: prompt-capture-log
timestamp: '2025-12-15T06:50:32.211179Z'
summary: Use NDJSON for Log Format
phase: architecture
tags:
- prompt-capture-log
- adr
- architecture
---

## Context
The log file needs to store multiple entries over time, potentially across many sessions. We need a format that supports:
- Atomic appends without reading/rewriting the entire file
- Resistance to corruption (one bad entry shouldn't invalidate all data)
- Easy parsing for analysis
- Human readability for debugging

## Decision
Use NDJSON (Newline-Delimited JSON) format where each line is a self-contained JSON object.

## Alternatives Considered
- JSON Array
- SQLite
- Plain text

---
type: decisions
spec: prompt-capture-log
timestamp: '2025-12-15T06:50:32.257829Z'
summary: Python for Hook Implementation
phase: architecture
tags:
- prompt-capture-log
- adr
- architecture
- python
- hooks
---

## Context
The hook needs to integrate with Claude Code's hook system, which supports command execution. The existing hookify plugin is written in Python.

## Decision
Implement the prompt capture hook in Python to match the existing hookify plugin infrastructure.

## Alternatives Considered
- Node.js/TypeScript
- Bash script
- Go binary

---
type: decisions
spec: prompt-capture-log
timestamp: '2025-12-15T06:50:32.303395Z'
summary: File-Based Toggle Marker
phase: architecture
tags:
- prompt-capture-log
- adr
- architecture
- ci-cd
---

## Context
Need a way to persist the "logging enabled" state across Claude Code sessions. The toggle must be:
- Project-specific (different projects can have different states)
- Visible and debuggable
- Persistent without a database

## Decision
Use a marker file (`.prompt-log-enabled`) in the project directory. Presence = enabled, absence = disabled.

## Alternatives Considered
- JSON config file
- Environment variable
- Global settings.json
- Database

---
type: decisions
spec: prompt-capture-log
timestamp: '2025-12-15T06:50:32.352788Z'
summary: Filter Pipeline Order (Secrets → Profanity)
phase: architecture
tags:
- prompt-capture-log
- adr
- architecture
---

## Context
Both profanity and secrets need to be filtered. The order of filtering could affect results.

## Decision
Filter secrets first, then profanity.

## Alternatives Considered
- Profanity → Secrets
- Single pass

---
type: decisions
spec: prompt-capture-log
timestamp: '2025-12-15T06:50:32.400094Z'
summary: Response Summaries via Heuristics
phase: architecture
tags:
- prompt-capture-log
- adr
- architecture
---

## Context
Need to capture Claude's responses for complete interaction logging, but full responses are too verbose (often 1000+ words). Options for summarization:
- Use LLM to summarize (adds latency, cost)
- Use heuristics (fast, free, less accurate)

## Decision
Use heuristic-based summarization: extract first paragraph, key bullet points, truncate to 500 characters.

## Alternatives Considered
- LLM summarization
- Full response logging
- No response capture

---
type: decisions
spec: prompt-capture-log
timestamp: '2025-12-15T06:50:32.449375Z'
summary: Hook Integration Point
phase: architecture
tags:
- prompt-capture-log
- adr
- architecture
- hooks
---

## Context
Need to choose how to integrate with Claude Code's hook system. Options:
- Standalone hook in `~/.claude/hooks/`
- Extension to hookify plugin
- New dedicated plugin

## Decision
Implement as a standalone hook in `~/.claude/hooks/` with its own registration, separate from but compatible with hookify.

## Alternatives Considered
- Extend hookify
- New plugin

---
type: decisions
spec: quality-release-ci-github-act
timestamp: '2025-12-15T06:50:32.497152Z'
summary: Use uv for Python Package Management
phase: architecture
tags:
- quality-release-ci-github-act
- adr
- architecture
- python
- ci-cd
---

## Context
The CI pipeline needs to install Python dependencies quickly and reliably. Options include pip, poetry, pipenv, and uv.

## Decision
Use **uv** (by Astral) for package management in CI and local development.

## Alternatives Considered
- pip + pip-tools
- poetry
- pipenv

---
type: decisions
spec: quality-release-ci-github-act
timestamp: '2025-12-15T06:50:32.561770Z'
summary: Use ruff for Linting and Formatting
phase: architecture
tags:
- quality-release-ci-github-act
- adr
- architecture
- python
---

## Context
Python code needs formatting and linting. Traditional tools include Black, isort, flake8, pylint.

## Decision
Use **ruff** for both formatting and linting.

## Alternatives Considered
- Black + isort + flake8
- Black + pylint
- autopep8

---
type: decisions
spec: quality-release-ci-github-act
timestamp: '2025-12-15T06:50:32.608549Z'
summary: Use Stable Action Versions (v4 over v6)
phase: architecture
tags:
- quality-release-ci-github-act
- adr
- architecture
- git
- python
- ci-cd
- testing
---

## Context
GitHub Actions like `actions/checkout` have multiple major versions available. v6 is latest but requires runner v2.327.1+.

## Decision
Use **v4** versions of core actions for stability.

```yaml
actions/checkout@v4
actions/setup-python@v4  # Note: We use astral-sh/setup-uv instead
actions/upload-artifact@v4
actions/download-artifact@v4
```

Use `astral-sh/setup-uv@v4` for Python setup (includes uv and Python).

## Alternatives Considered
- v6 (latest)
- Pin to SHA
- Use latest tag

---
type: decisions
spec: quality-release-ci-github-act
timestamp: '2025-12-15T06:50:32.654106Z'
summary: 'Matrix Testing with fail-fast: false'
phase: architecture
tags:
- quality-release-ci-github-act
- adr
- architecture
- python
- testing
---

## Context
Testing across Python 3.11, 3.12, 3.13 requires a strategy matrix. Default behavior cancels other jobs if one fails.

## Decision
Use `fail-fast: false` to see all failures.

```yaml
strategy:
  fail-fast: false
  matrix:
    python-version: ["3.11", "3.12", "3.13"]
```

## Alternatives Considered
- fail-fast: true (default)
- Single version

---
type: decisions
spec: quality-release-ci-github-act
timestamp: '2025-12-15T06:50:32.698578Z'
summary: Separate Quality and Test Jobs
phase: architecture
tags:
- quality-release-ci-github-act
- adr
- architecture
- security
- testing
---

## Context
Quality checks (lint, format, type check) and tests could be in one job or separate jobs.

## Decision
Keep quality checks and tests as **separate jobs** that run in parallel.

```yaml
jobs:
  quality:
    # formatting, linting, type checking, security
  test:
    # pytest with matrix
```

## Alternatives Considered
- Single job
- Quality as required, tests optional
- Test depends on quality

---
type: decisions
spec: quality-release-ci-github-act
timestamp: '2025-12-15T06:50:32.743917Z'
summary: Use softprops/action-gh-release for Releases
phase: architecture
tags:
- quality-release-ci-github-act
- adr
- architecture
- git
---

## Context
GitHub Releases can be created via API directly or using community actions.

## Decision
Use **softprops/action-gh-release@v2** for release creation.

## Alternatives Considered
- gh CLI directly
- GitHub API via curl
- actions/create-release

---
type: decisions
spec: quality-release-ci-github-act
timestamp: '2025-12-15T06:50:32.779322Z'
summary: Extract Changelog vs Generate Release Notes
phase: architecture
tags:
- quality-release-ci-github-act
- adr
- architecture
---

## Context
Release notes can be auto-generated from commits or extracted from a maintained CHANGELOG.md.

## Decision
**Extract changelog section** from plugins/cs/CHANGELOG.md rather than auto-generate.

## Alternatives Considered
- generate_release_notes: true
- Conventional commits + changelog generator
- No release notes

---
type: decisions
spec: quality-release-ci-github-act
timestamp: '2025-12-15T06:50:32.812916Z'
summary: Minimal Workflow Permissions
phase: architecture
tags:
- quality-release-ci-github-act
- adr
- architecture
- git
- ci-cd
---

## Context
GitHub Actions workflows can request various permission levels. Default can be quite permissive.

## Decision
Explicitly set **minimal permissions** per workflow.

```yaml
# CI workflow
permissions:
  contents: read

# Release workflow
permissions:
  contents: write
```

## Alternatives Considered
- Default permissions
- Job-level permissions
- No explicit permissions

---
type: decisions
spec: quality-release-ci-github-act
timestamp: '2025-12-15T06:50:32.859176Z'
summary: Python 3.11+ Minimum Version
phase: architecture
tags:
- quality-release-ci-github-act
- adr
- architecture
- python
- testing
---

## Context
Need to choose minimum Python version for compatibility testing.

## Decision
Support **Python 3.11, 3.12, 3.13** (3.11+ minimum).

## Alternatives Considered
- 3.12+ only
- 3.10+
- 3.14 only

---
type: decisions
spec: quality-release-ci-github-act
timestamp: '2025-12-15T06:50:32.907892Z'
summary: shellcheck for Shell Script Validation
phase: architecture
tags:
- quality-release-ci-github-act
- adr
- architecture
- testing
---

## Context
The plugin includes shell scripts that should be validated for correctness and portability.

## Decision
Use **shellcheck** (pre-installed on ubuntu-latest) for shell script validation.

## Alternatives Considered
- shfmt only
- bash -n
- No validation

---
type: decisions
spec: pre-post-steps-commands
timestamp: '2025-12-15T06:50:32.957895Z'
summary: Use Claude Code Native Hook System
phase: architecture
tags:
- pre-post-steps-commands
- adr
- architecture
- hooks
- embeddings
---

## Context
We need a mechanism to execute pre and post steps around `/cs:*` commands. Options include:
1. Claude Code's native hook system (SessionStart, Stop, UserPromptSubmit)
2. Command wrapper scripts
3. Embedded logic in command .md files

## Decision
Use Claude Code's native hook system with three hooks:
- SessionStart for context loading
- UserPromptSubmit for command detection and pre-steps
- Stop for post-steps

## Alternatives Considered
- Command wrapper scripts
- Embedded logic

---
type: decisions
spec: pre-post-steps-commands
timestamp: '2025-12-15T06:50:33.010401Z'
summary: SessionStart for Context Loading (Not Per-Command)
phase: architecture
tags:
- pre-post-steps-commands
- adr
- architecture
- git
- hooks
---

## Context
Context loading (CLAUDE.md, git state, project structure) could happen:
1. Once on session start (SessionStart hook)
2. Before each /cs:* command (UserPromptSubmit hook)

## Decision
Load context once on session start via SessionStart hook.

---
type: decisions
spec: pre-post-steps-commands
timestamp: '2025-12-15T06:50:33.046122Z'
summary: Security Review as Pre-Step for /cs:c
phase: architecture
tags:
- pre-post-steps-commands
- adr
- architecture
- security
---

## Context
Security review could be:
1. A pre-step before /cs:c (audit before close-out)
2. A post-step after /cs:p (audit the plan)
3. A post-step after /cs:c (audit after close-out)
4. Applied to all commands

## Decision
Security review is a pre-step for `/cs:c` only.

---
type: decisions
spec: pre-post-steps-commands
timestamp: '2025-12-15T06:50:33.092427Z'
summary: Configuration via worktree-manager.config.json
phase: architecture
tags:
- pre-post-steps-commands
- adr
- architecture
- configuration
---

## Context
Configuration for pre/post steps could be stored in:
1. Existing worktree-manager.config.json
2. New dedicated lifecycle.json file
3. Per-project .cs-config.json files

## Decision
Extend worktree-manager.config.json with a `lifecycle` section.

---
type: decisions
spec: pre-post-steps-commands
timestamp: '2025-12-15T06:50:33.139622Z'
summary: Fail-Open Design for All Hooks
phase: architecture
tags:
- pre-post-steps-commands
- adr
- architecture
- hooks
- ci-cd
---

## Context
When hooks encounter errors, they could:
1. Fail-open (log error, continue with command)
2. Fail-closed (block command execution)
3. Prompt user to decide

## Decision
All hooks follow fail-open design - errors are logged to stderr but never block command execution.

---
type: decisions
spec: pre-post-steps-commands
timestamp: '2025-12-15T06:50:33.192316Z'
summary: Temp File for Hook State Passing
phase: architecture
tags:
- pre-post-steps-commands
- adr
- architecture
- hooks
---

## Context
Hooks are stateless processes. To pass command context from UserPromptSubmit to Stop hook, options include:
1. CLAUDE_ENV_FILE environment variable
2. Temporary state file (.cs-session-state.json)
3. Reading from transcript file

## Decision
Use temporary state file `.cs-session-state.json` in project directory.

## Alternatives Considered
- CLAUDE_ENV_FILE
- Transcript file

---
type: decisions
spec: pre-post-steps-commands
timestamp: '2025-12-15T06:50:33.242228Z'
summary: Strict Phase Separation - /cs:p NEVER Implements
phase: architecture
tags:
- pre-post-steps-commands
- adr
- architecture
- ci-cd
---

## Context
During specification work, Claude incorrectly proceeded to implementation after the user said "approve work", interpreting approval of the spec as authorization to implement. This highlighted a critical gap: no explicit boundary between planning and implementation phases.

Options:
1. Trust Claude to interpret user intent correctly (status quo)
2. Add explicit guards in command files to enforce phase boundaries
3. Require separate confirmation before implementation

## Decision
Enforce strict phase separation through command file modifications:
- `/cs:p` includes `<post_approval_halt>` section that HALTS after spec approval
- `/cs:i` is the ONLY authorized entry point for implementation
- Plan approval explicitly does NOT authorize implementation

---
type: decisions
spec: worktree-config-install
timestamp: '2025-12-15T06:50:33.292256Z'
summary: User Config Location
phase: architecture
tags:
- worktree-config-install
- adr
- architecture
- configuration
---

## Context
The worktree-manager skill needs a stable location for user configuration that survives plugin updates. The current location (`plugins/cs/skills/worktree-manager/config.json`) is overwritten when the plugin updates.

## Decision
Store user configuration at `~/.claude/worktree-manager.config.json`.

## Alternatives Considered
- `~/.config/worktree-manager/config.json`
- `~/.worktree-manager.json`
- Environment variables

---
type: decisions
spec: worktree-config-install
timestamp: '2025-12-15T06:50:33.342964Z'
summary: Config Lookup Precedence
phase: architecture
tags:
- worktree-config-install
- adr
- architecture
- configuration
---

## Context
Scripts need to find configuration, but user config may not exist (first run) or may be incomplete.

## Decision
Use a fallback chain: User config → Template → Hardcoded defaults

```
1. Check ~/.claude/worktree-manager.config.json (user preferences)
2. Fall back to plugins/.../config.template.json (bundled defaults)
3. Fall back to hardcoded defaults (last resort)
```

## Alternatives Considered
- Fail if no user config
- Copy template to user location automatically
- Merge at runtime

---
type: decisions
spec: worktree-config-install
timestamp: '2025-12-15T06:50:33.391116Z'
summary: Interactive Setup via AskUserQuestion
phase: architecture
tags:
- worktree-config-install
- adr
- architecture
- configuration
---

## Context
First-time users need to configure worktree-manager, but editing JSON files manually is tedious and error-prone.

## Decision
Use Claude's `AskUserQuestion` tool to interactively gather configuration preferences during first-time setup or when `/cs:wt:setup` is run.

## Alternatives Considered
- CLI prompts (readline/fzf)
- Web UI
- Just use defaults

---
type: decisions
spec: worktree-config-install
timestamp: '2025-12-15T06:50:33.439157Z'
summary: Template File Naming
phase: architecture
tags:
- worktree-config-install
- adr
- architecture
- configuration
---

## Context
The bundled configuration file serves as a template/default, not the active user config. The name should reflect this.

## Decision
Rename `config.json` to `config.template.json`.

## Alternatives Considered
- `config.default.json`
- `config.example.json`
- Keep `config.json`

---
type: decisions
spec: worktree-config-install
timestamp: '2025-12-15T06:50:33.488539Z'
summary: Prompt Log Timing Fix Location
phase: architecture
tags:
- worktree-config-install
- adr
- architecture
---

## Context
When `/cs:p` creates a worktree and launches a new agent, the `.prompt-log-enabled` marker isn't created until after the first prompt is processed, causing the first prompt to be missed.

## Decision
Create the spec directory and `.prompt-log-enabled` marker in the worktree BEFORE launching the agent, within the `p.md` command's `mandatory_first_actions` section.

## Alternatives Considered
- Add flag to launch-agent.sh
- Separate setup script
- Hook modification

---
type: decisions
spec: cs-memory
timestamp: '2025-12-15T06:50:33.537574Z'
summary: Git Notes for Canonical Storage
phase: architecture
tags:
- cs-memory
- adr
- architecture
- git
- ci-cd
- storage
---

## Context
We need persistent storage for AI-generated memories that:
- Survives across Claude Code sessions
- Travels with the repository
- Attaches to specific commits
- Is version-controlled
- Doesn't pollute commit history

## Decision
Use Git notes as the canonical storage layer for all memories.

## Alternatives Considered
- Separate files (DECISIONS.md, LEARNINGS.md)
- SQLite database (committed)
- External database (e.g., PostgreSQL)
- Commit message metadata (trailers)

---
type: decisions
spec: cs-memory
timestamp: '2025-12-15T06:50:33.575897Z'
summary: SQLite + sqlite-vec for Index Layer
phase: architecture
tags:
- cs-memory
- adr
- architecture
- database
- ci-cd
- embeddings
---

## Context
Semantic search requires vector similarity operations. Options:
- Cloud vector databases (Pinecone, Weaviate)
- Self-hosted vector databases (Milvus, Qdrant)
- Embedded solutions (FAISS, sqlite-vec)

## Decision
Use SQLite with the sqlite-vec extension for the vector index.

- **Local-first**: No external dependencies or API calls
- **Portable**: Single file, cross-platform
- **Rebuildable**: Index is derived data, can regenerate from notes
- **Sufficient scale**: Handles thousands of vectors efficiently
- **SQL familiarity**: Standard query patterns for metadata filtering

## Alternatives Considered
- FAISS
- ChromaDB
- sqlite-vss

---
type: decisions
spec: cs-memory
timestamp: '2025-12-15T06:50:33.613429Z'
summary: Local Embedding Model
phase: architecture
tags:
- cs-memory
- adr
- architecture
- ci-cd
- embeddings
---

## Context
Semantic search requires text embeddings. Options:
- Cloud APIs (OpenAI, Cohere, Voyage)
- Local models (sentence-transformers, Ollama)

## Decision
Use local embedding generation via sentence-transformers, defaulting to `all-MiniLM-L6-v2` (384 dimensions).

- **Privacy**: No project data leaves the machine
- **Offline capable**: Works without internet
- **Free**: No API costs
- **Fast enough**: ~50ms per embedding on CPU
- **Quality**: Sufficient for our semantic similarity needs

## Alternatives Considered
- OpenAI text-embedding-3-small
- Ollama with embedding model
- Larger local models (e5-large, bge-large)

---
type: decisions
spec: cs-memory
timestamp: '2025-12-15T06:50:33.662292Z'
summary: YAML Front Matter + Markdown Body
phase: architecture
tags:
- cs-memory
- adr
- architecture
---

## Context
Notes need both machine-parseable metadata and human-readable content.

## Decision
Use YAML front matter (delimited by `---`) for structured metadata, followed by Markdown body for content.

- **Familiar format**: Common in static site generators, docs
- **Machine parseable**: YAML is structured, typed
- **Human readable**: Markdown renders nicely
- **Flexible**: Body can contain any Markdown structure
- **Tooling**: Many parsers available

---
type: decisions
spec: cs-memory
timestamp: '2025-12-15T06:50:33.711891Z'
summary: Namespace-per-Type Organization
phase: architecture
tags:
- cs-memory
- adr
- architecture
- git
- ci-cd
- storage
- memory-system
---

## Context
Memories have different types (decisions, learnings, blockers). Options:
- Single namespace, type in metadata
- Separate namespace per type

## Decision
Use separate Git notes namespaces for each memory type.

- **Isolation**: Different sync/retention policies possible
- **Query efficiency**: Type filtering at storage level
- **Clarity**: `refs/notes/cs/decisions` is self-documenting
- **Git operations**: Can list/manage types independently
